#!/usr/bin/env python3
import os
from gen_html import generate_html
from gen_svg import geojson_to_svg, geojson_bh_to_svg, navi_to_svg
import re
def process_geojson_file(current_dir, base_name):
    """处理指定的GeoJSON文件并生成SVG和HTML"""
    # 输入GeoJSON文件
    geojson_file = os.path.join(current_dir, 'map', f'{base_name}.geojson')
    
    # 如果文件不存在，则返回
    if not os.path.exists(geojson_file):
        print(f"文件不存在: {geojson_file}")
        return False
    
    # 输出SVG文件
    svg_file = os.path.join(current_dir, 'map', f'{base_name}.svg')
    
    # 检查SVG文件是否已存在，如果存在则保留原文件
    if not os.path.exists(svg_file):
        # 关键：根据base_name选择不同的SVG生成方式
        if base_name == "0-BH":
            bh_geojson_file = os.path.join(current_dir, 'map', '0-BH.geojson')
            cw_geojson_file = os.path.join(current_dir, 'map', '0-CW.geojson')
            geojson_bh_to_svg(bh_geojson_file, cw_geojson_file, svg_file)
        else:
            geojson_to_svg(geojson_file, svg_file, width=1000, height=800)
        print(f"已生成SVG文件: {base_name}.svg")
    else:
        print(f"SVG文件已存在，保留原文件: {base_name}.svg")
    
    print(f"已处理文件: {base_name}.geojson")
    return True

def generate_merged_html(svg_files, html_file, layer_names, view_params=None):
    """将多个SVG文件叠加到一个SVG画布中显示，支持整体交互
    
    Args:
        svg_files: SVG文件路径列表
        html_file: 输出的HTML文件路径
        layer_names: 图层名称列表
        view_params: 可选，初始视图参数 (min_sx, min_sy, max_sx, max_sy, view_width, view_height, show_scale)
    """

    svg_g_list = []
    width = height = None
    for svg_path in svg_files:
        with open(svg_path, 'r', encoding='utf-8') as f:
            svg_content = f.read()
            # 提取<svg ...>标签的width和height
            if width is None or height is None:
                m = re.search(r'<svg[^>]*width=["\'](\d+)["\'][^>]*height=["\'](\d+)["\']', svg_content)
                if m:
                    width = m.group(1)
                    height = m.group(2)
            # 提取<g>...</g>内容（或全部内容去掉<svg>包裹）
            g_match = re.search(r'<g[\s\S]*?</g>', svg_content)
            if g_match:
                svg_g_list.append(g_match.group(0))
            else:
                # 如果没有<g>，则取<svg>内部内容
                inner = re.sub(r'<svg[^>]*>', '', svg_content)
                inner = re.sub(r'</svg>', '', inner)
                svg_g_list.append(inner)
    if width is None or height is None:
        width = '1000'
        height = '800'
    # 强制统一viewBox和尺寸
    merged_svg = '<svg width="1000" height="800" viewBox="0 0 1000 800" xmlns="http://www.w3.org/2000/svg">\n' + '\n'.join(svg_g_list) + '\n</svg>'
    
    # 准备初始化参数
    init_params = ""
    if view_params:
        min_x, min_y, max_x, max_y, view_width, view_height, scale = view_params
        # 计算中心点和缩放比例
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        # 直接使用传递进来的scale值
        optimal_scale = scale
        # 计算最佳缩放比例 (考虑内容适应显示区域)
        # content_width = max_x - min_x
        # content_height = max_y - min_y
        # scale_x = 1000 / content_width if content_width > 0 else 1
        # scale_y = 800 / content_height if content_height > 0 else 1
        # optimal_scale = min(scale_x, scale_y) * 0.9  # 留一点边距
        
        init_params = f"""
            // 初始化导航视图参数
            translateX = {-center_x * optimal_scale + 500};
            translateY = {-center_y * optimal_scale + 400};
            scale = {optimal_scale};
            updateTransform();
        """
    print(f"center_x: {center_x}, center_y: {center_y}, optimal_scale: {optimal_scale},init_params: {init_params}")
    html_content = '''<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>多图层叠加地图</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f0f0f0; margin: 0; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .map-block { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #0001; padding: 20px; }
        .map-title { font-size: 1.2em; margin-bottom: 10px; }
        .map-container { width: 100%; height: 800px; position: relative; background: #eaeaea; overflow: hidden; }
        .controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; }
        .controls button { width: 40px; height: 40px; font-size: 20px; background: white; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        .controls button:hover { background: #f0f0f0; }
        svg { position: absolute; top: 50%; left: 50%; transform-origin: center center; cursor: move; }
    </style>
</head>
<body>
    <div class="container">
        <h1>多图层叠加地图（可控）</h1>
        <div class="map-block">
            <div class="map-title">所有图层叠加</div>
            <div class="map-container" id="map-container">
                {merged_svg}
            </div>
            <div class="controls">
                <button id="zoom-in">+</button>
                <button id="zoom-out">-</button>
                <button id="reset">⟳</button>
            </div>
        </div>
    </div>
    <script>
        function setupMapInteraction(svg, container, zoomInBtn, zoomOutBtn, resetBtn) {
            let isDragging = false;
            let startX, startY;
            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            const svgWidth = parseInt(svg.getAttribute('width'));
            const svgHeight = parseInt(svg.getAttribute('height'));
            translateX = -svgWidth / 2;
            translateY = -svgHeight / 2;
            updateTransform();
            {init_params}
            svg.addEventListener('mousedown', function(event) {
                isDragging = true;
                startX = event.clientX - translateX;
                startY = event.clientY - translateY;
                svg.style.cursor = 'grabbing';
            });
            document.addEventListener('mousemove', function(event) {
                if (!isDragging) return;
                translateX = event.clientX - startX;
                translateY = event.clientY - startY;
                updateTransform();
            });
            document.addEventListener('mouseup', function() {
                isDragging = false;
                svg.style.cursor = 'move';
            });
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const svgX = (mouseX - translateX) / scale;
                const svgY = (mouseY - translateY) / scale;
                const scaleFactor = event.deltaY < 0 ? 1.1 : 0.9;
                scale *= scaleFactor;
                scale = Math.max(0.1, Math.min(scale, 30));
                translateX = mouseX - svgX * scale;
                translateY = mouseY - svgY * scale;
                updateTransform();
            });
            zoomInBtn.addEventListener('click', function() { changeScale(1.2); });
            zoomOutBtn.addEventListener('click', function() { changeScale(0.8); });
            resetBtn.addEventListener('click', function() { 
                scale = 1;
                translateX = -svgWidth / 2;
                translateY = -svgHeight / 2;
                updateTransform();
                {init_params}
            });
            function changeScale(factor) {
                const rect = container.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const svgCenterX = (centerX - translateX) / scale;
                const svgCenterY = (centerY - translateY) / scale;
                scale *= factor;
                scale = Math.max(0.1, Math.min(scale, 30));
                translateX = centerX - svgCenterX * scale;
                translateY = centerY - svgCenterY * scale;
                updateTransform();
            }
            function updateTransform() {
                svg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }
        }
        document.addEventListener('DOMContentLoaded', function() {
            setupMapInteraction(
                document.querySelector('#map-container svg'),
                document.getElementById('map-container'),
                document.getElementById('zoom-in'),
                document.getElementById('zoom-out'),
                document.getElementById('reset')
            );
        });
    </script>
</body>
</html>'''.replace('{merged_svg}', merged_svg).replace('{init_params}', init_params)
    with open(html_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"已生成多图层合并HTML: {html_file}")

def process_navigation(current_dir, start_id="B1-001", end_id="B1-068"):
    """生成从起点到终点的导航路径SVG"""
    # 输入GeoJSON文件
    bh_geojson_file = os.path.join(current_dir, 'map', '0-BH.geojson')
    dp3_geojson_file = os.path.join(current_dir, 'map', '0-DP3.geojson')
    
    # 如果文件不存在，则返回
    if not os.path.exists(bh_geojson_file) or not os.path.exists(dp3_geojson_file):
        print(f"导航所需文件不存在")
        return False
    
    # 输出SVG文件
    svg_file = os.path.join(current_dir, 'map', f'nav.svg')   

    nav_view_params = navi_to_svg(bh_geojson_file, dp3_geojson_file, svg_file, start_id, end_id, width=1000, height=800)
    print(f"已生成导航SVG: nav.svg")

    return True, nav_view_params

def main():
    # 当前脚本所在目录
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 确保map目录存在
    map_dir = os.path.join(current_dir, 'map')
    if not os.path.exists(map_dir):
        os.makedirs(map_dir)
    
    # 要处理的文件列表
    files_to_process = ['0-DP3', '0-DP2', '0-CW', '0-BH']
    processed_files = []
    
    # 处理每个文件
    for base_name in files_to_process:
        print(f"正在处理 {base_name}.geojson...")
        if process_geojson_file(current_dir, base_name):
            processed_files.append(base_name)
    
    # 生成导航路径
    print("正在生成导航路径...")
    nav_view_params = None
    is_success, nav_view_params = process_navigation(current_dir, "B1-001", "B1-068")
    if is_success:
        print(f"已生成导航路径: nav.svg")
        print(f"nav_view_params: {nav_view_params}")
    
    print("处理完成！")

        
    # 新增：生成多图层合并HTML
    svg_files = [
        os.path.join(current_dir, 'map', '0-DP3.svg'),
        os.path.join(current_dir, 'map', '0-DP2.svg'),
        os.path.join(current_dir, 'map', '0-CW.svg'),
        os.path.join(current_dir, 'map', '0-BH.svg'),
    ]
    
    # 添加导航SVG文件如果存在
    nav_svg_file = os.path.join(current_dir, 'map', 'nav.svg')
    if os.path.exists(nav_svg_file):
        svg_files.append(nav_svg_file)
        layer_names = ['DP3', 'DP2', 'CW', 'BH', '导航路径']
    else:
        layer_names = ['DP3', 'DP2', 'CW', 'BH']
        
    merged_html_file = os.path.join(current_dir, 'map', 'merged_layers.html')
    generate_merged_html(svg_files, merged_html_file, layer_names, nav_view_params)


if __name__ == "__main__":
    main()